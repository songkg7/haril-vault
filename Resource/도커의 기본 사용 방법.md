---
title: 도커의 기본 사용 방법
date: 2023-10-07 12:54:00 +0900
aliases: 
tags:
  - docker
  - container
  - study
categories: 
updated: 2023-10-07 14:12:12 +0900
related: "[[Docker|Docker]]"
---

모든 컨테이너는 실행될 때마다 id 가 매번 바뀌며 IP 주소 역시 바뀔 확률이 높다. 모든 컨테이너는 같은 컴퓨터에서 실행될 텐데 왜 계속 바뀌는 것일까?

## 컨테이너란 무엇인가?

컨테이너는 일종의 상자. 이 상자 안에는 애플리케이션과 실행할 컴퓨터(IP 주소, 이름, 디스크 드라이브 등)가 함께 들어 있다.

호스트명, IP 주소, 파일 시스템까지 이들은 모두 도커가 만들어낸 가상 리소스다. 이들이 서로 엮여 애플리케이션이 동작할 수 있는 환경이 만들어진다.

상자 안에서는 상자 밖의 환경을 볼 수 없다. 그러나 이 상자는 어떤 컴퓨터상에서 동작하는 것이고, 이 컴퓨터는 이 상자 말고도 다른 상자를 여러개 실행할 수 있다. 이들 상자는 서로 독립적인 환경을 갖지만 상자가 실행되는 컴퓨터의 CPU 와 메모리, [[운영체제 (Operating system)]]를 공유한다.

이러한 부분은 격리와 밀집이라는 모순돼 보이는 조건을 동시에 만족할 수 있게 한다. 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행하는 것을 의미한다. 그러나 서로 다른 여러 애플리케이션을 실행하는 데는 제약이 따른다. 자바나 닷넷 등 필요로 하는 런타임의 버전이 서로 다를 수도 있고, 서로 호환되지 않는 버전의 라이브러리를 사용하는가 하면, 어느 한 애플리케이션이 과다한 리소스를 필요로 해 다른 애플리케이션의 리소스가 부족해질 수도 있다. 이런 면을 고려하면 애플리케이션은 서로 독립된 환경에서 실행돼야 한다. 하지만 그럴 경우 한 컴퓨터에서 여러 애플리케이션을 실행할 수 없게 되고, 다시 말해 밀집을 달성할 수 없다.

이 모순된 조건을 동시 달성하려던 첫 번째 시도는 가상머신([[Virtual Machine]])을 사용하는 것이었다. 가상 머신은 애플리케이션이 실행될 독립적 환경이 생긴다는 점에서는 컨테이너와 큰 차이가 없다. 다만 가상 머신은 컨테이너와 달리 호스트 컴퓨터의 운영체제를 공유하지 않고 별도의 운영체제를 필요로 한다.

- 각각의 가상 머신은 자신만의 운영체제를 별도로 갖는다. 이 운영체제는 애플리케이션이 사용해야 할 CPU 와 메모리 자원을 상당량 차지한다.
- 운영체제의 라이선스 비용과 운영체제 업데이트 설치 부담이 추가로 생긴다.
- 격리는 달성할 수 있지만 밀집은 제공하지 못한다.

컨테이너는 이러한 단점을 해결할 수 있다.

- 호스트의 운영체제를 공유하므로 필요한 리소스가 크게 경감된다.
- 그만큼 실행도 빠르고 같은 호스트 컴퓨터에서 가상 머신에 비해 더 많은 수의 애플리케이션을 실행할 수 있다.
- 컨테이너 역시 외부와 독립된 환경을 제공하므로 밀집과 격리가 동시에 달성된다.

## 컨테이너를 원격 컴퓨터처럼 사용하기

도커 컨테이너는 호스트 컴퓨터의 운영체제를 공유한다. 그렇기 때문에 호스트 컴퓨터가 리눅스 머신이라면 리눅스 셸이 뜨고, 윈도 머신이라면 윈도 명령 프롬프트가 뜨는 것이다.

도커는 컨테이너를 실행할 때마다 무작위로 생성한 ID 값을 부여한다. 이 ID 값 중 일부가 호스트명이 된다. 특정한 컨테이너에 대해 실행할 수 있는 다양한 docker container 명령이 있는데, 이 때 컨테이너를 특정하려면 컨테이너 ID의 처음 몇 글자를 지정하면 된다.

```bash
# container id 가 f1695de1f2ec 일 경우
# top
docker container top f1

# log
docker container logs f1
```

도커는 애플리케이션의 표준 출력으로부터 로그를 수집한다.

도커를 사용하는 한 컨테이너는 모두 똑같다는 점이다. 도커를 적용하면 모든 애플리케이션 위에 관리를 위한 계층이 하나 추가된다.

## 컨테이너를 사용해 웹 사이트 호스팅하기

1. 컨테이너는 내부의 애플리케이션이 실행 중이어야 컨테이너의 상태도 실행 중이 된다.
2. 컨테이너가 종료되도 컨테이너는 사라지지 않는다.

컨테이너가 백그라운드에서 동작하면서 네트워크를 주시(listen)하게 하려면 `docker container run` 명령에 다음과 같은 두 개의 플래그를 적용해야 한다.

- `--detach`, `-d`: 컨테이너를 백그라운드에서 실행하며 컨테이너 ID 를 출력한다.
- `--publish`, `-p`: 컨테이너의 포트를 호스트 컴퓨터에 공개한다.

`--detach` 플래그를 적용해 실행한 컨테이너는 마치 리눅스 데몬이나 윈도 서비스처럼 백그라운드로 동작하며 겉으로 드러나지 않는다.

컨테이너의 포트를 호스트 컴퓨터에 공개하는 원리는 좀 더 복잡하다. 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서 그중 필요한 것을 컨테이너에 전달할 수 있다.

컨테이너는 기본적으로 외부 환경에 노출되지 않는다. 각 컨테이너는 고유의 IP 주소를 갖지만, 이 IP 주소는 도커가 관리하는 내부 가상 네트워크의 주소지 호스트 컴퓨터가 연결된 물리 네트워크에 연결된 것이 아니다. 컨테이너의 포트를 공개한다는 것은 도커가 호스트 컴퓨터의 포트를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너로 전달해주는 것이다.

## 도커가 컨테이너를 실행하는 원리

- 도커 엔진은 도커의 관리 기능을 맡는 컴포넌트다. 로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다. 도커 엔진은 항시 동작하는 백그라운드 프로세스다.
- 도커 엔진은 도커 API 를 통해 맡은 기능을 수행한다. 도커 API 는 표준 HTTP 기반 REST API 다. 도커 엔진의 설정을 수정하면 이 API 를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단(default)하거나 허용할 수 있다.
- 도커 명령행 인터페이스(Docker CLI)는 도커 API의 클라이언트다. 우리가 도커 명령을 사용할 때 실제로 도커 API를 호출하는 것이 바로 도커 CLI다.

도커 API 는 명세가 공개돼 있다. 그러므로 도커 CLI 외의 다른 클라이언트를 사용할 수 있다. 이미 그래픽 인터페이스를 통해 시각적으로 컨테이너를 관리할 수 있는 클라이언트가 몇 가지 나와있다.

도커 엔진은 [[containerd]] 라는 컴포넌트를 통해 컨테이너를 실제로 관리하는데, [[containerd]] 는 호스트 운영체제가 제공하는 기능을 통해 컨테이너, 즉 가상 환경을 만든다.


> [!NOTE]
> containerd 는 CNCF 에서 관리하는 오픈 소스 프로젝트이며, 컨테이너는 개방형 컨테이너 이니셔티브(Open Container Initiative, OCI)라는 이름으로 공개도니 개방형 표준이라는 점은 알아둘 필요가 있다.
