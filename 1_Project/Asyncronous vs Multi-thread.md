---
title: 
date: 2024-02-11 16:19:00 +0900
aliases: 
tags:
  - async
  - multi-thread
  - event-loop
categories: 
updated: 2024-03-20 21:31:32 +0900
---

> 멀티 스레딩 방식은 비동기의 구현 방식 중 한가지

## 비동기와 멀티스레드의 차이

비동기(Asynchronous)와 멀티스레드(Multithreading)는 모두 동시에 여러 작업을 처리하는 방식이지만, 그 원리와 동작 방식에는 차이가 있습니다.

1. 비동기:
- 비동기는 한 작업의 결과를 기다리지 않고 다른 작업을 동시에 처리할 수 있는 방식입니다.
- 주로 콜백(callback) 함수나 프로미스(promise) 등을 통해 비동기 작업을 수행합니다.
- 비동기 작업은 주로 I/O 작업 (파일 읽기/쓰기, 네트워크 통신 등) 이나 대규모 계산과 같이 시간이 오래 걸리는 작업에 많이 사용됩니다.
- 비동기 방식은 단일 스레드에서 여러 개의 작업을 처리하기 때문에 메모리 사용량과 컨텍스트 전환(Context Switching) 오버헤드가 적습니다.

2. 멀티스레드:
- 멀티스레딩은 하나의 프로그램 내에서 여러 개의 스레드를 생성하여 동시에 여러 작업을 처리하는 방식입니다.
- 각 스레드는 독립적으로 실행되며, 공유 자원에 대한 접근 제어가 필요합니다.
- 멀티스레딩은 CPU 중심의 계산이나 병렬 처리가 필요한 작업에 사용됩니다.
- 멀티스레딩은 여러 개의 스레드가 동시에 실행되기 때문에 메모리 사용량과 컨텍스트 전환 오버헤드가 큽니다. 또한, 스레드 간 동기화 문제를 해결해야 하는 경우도 발생할 수 있습니다.

비동기와 멀티스레드는 각각의 장단점과 적용되는 상황이 다르기 때문에, 어떤 방식을 선택할지는 상황과 요구사항에 따라 결정해야 합니다.

## 단일 스레드 기반 비동기 구현

단일 스레드 기반의 비동기 구현은 이벤트 루프([[Event Loop|Event Loop]])를 통해 동작합니다. 이벤트 루프는 이벤트 큐(Event Queue)에 등록된 작업들을 순서대로 처리하며, 비동기 작업의 완료 여부를 확인하고 결과를 처리하는 역할을 합니다.

비동기 작업을 수행하기 위해서는 콜백 함수나 프로미스와 같은 메커니즘을 사용합니다. 예를 들어, 파일을 읽기 위한 비동기 함수인 `fs.readFile`은 파일의 내용을 읽는 작업이 완료되면 등록된 콜백 함수를 호출하여 결과를 전달합니다.

```javascript
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
```

이 코드에서 `readFile` 함수는 파일을 읽는 작업을 비동기적으로 실행하고, 작업이 완료되면 등록된 콜백 함수가 호출됩니다. 이때, 메인 스레드는 다른 작업을 수행할 수 있으며, 파일 읽기 작업의 결과가 준비되면 해당 콜백 함수가 실행됩니다.

단일 스레드 기반의 비동기 구현은 별도의 스레드를 생성하지 않고도 비동기 작업을 처리할 수 있기 때문에, 멀티스레딩보다 메모리 사용량과 컨텍스트 전환 오버헤드가 적습니다. 그러나, 이벤트 루프에서 작업을 처리하는 과정에서 블로킹되는 작업이 있다면 전체 애플리케이션의 응답성이 저하될 수 있습니다.

따라서, 단일 스레드 기반의 비동기 구현은 I/O 중심의 작업에 적합하며, CPU 중심의 계산이 필요한 작업에는 멀티스레딩을 고려해야 합니다.

## 시스템 콜이 필요한 상황에서의 이벤트 루프

시스템 콜(system call)은 [[Operating system|OS]]의 기능을 사용하기 위해 사용자 프로세스가 커널에게 요청하는 방식입니다. 시스템 콜은 파일 읽기/쓰기, 네트워크 통신, 프로세스 생성/종료 등과 같은 저수준의 작업을 수행할 때 사용됩니다.

이벤트 루프는 주로 비동기 작업을 처리하기 위해 사용되지만, 시스템 콜이 필요한 상황에서는 어떻게 동작할까요?

일반적으로 시스템 콜은 블로킹(blocking) 방식으로 동작합니다. 즉, 시스템 콜이 실행되면 해당 작업이 완료될 때까지 프로그램의 실행이 중단되고 대기 상태에 들어갑니다. 이러한 경우, 이벤트 루프도 같이 블로킹되어 다른 비동기 작업을 처리하지 못하고 대기 상태에 있게 됩니다.

따라서, 시스템 콜이 필요한 상황에서는 단일 스레드 기반의 비동기 구현도 멀티스레딩과 유사한 방식으로 동작해야 합니다. 예를 들어, Node.js에서는 libuv라는 라이브러리를 통해 이벤트 루프와 멀티스레딩을 조합하여 동작합니다.

libuv는 이벤트 루프를 단일 스레드에서 동작하면서, 시스템 콜이 필요한 작업은 별도의 스레드 풀(Thread Pool)에서 처리합니다. 이렇게 함으로써 시스템 콜이 블로킹되더라도 이벤트 루프는 계속해서 비동기 작업을 처리할 수 있습니다.

즉, 단일 스레드 기반의 비동기 구현은 일부 시스템 콜을 제외하고는 메인 스레드만 사용하므로 메모리 사용량과 컨텍스트 전환 오버헤드가 적습니다. 그러나, 시스템 콜이 필요한 작업은 멀티스레드를 활용하여 별도의 스레드에서 처리해야 합니다.

## 별도의 스레드에서 시스템콜을 한다고 해도 결국 그 스레드는 블로킹되는 것이 아닌가?

따라서 non-blocking I/O 작업을 처리할 수 있어야 하며, java 는 nio 패키지의 [[Selector]], channel 등으로 관리한다. non-blocking I/O 의 경우, OS 는 처리 결과를 다시 JVM 으로 통지할 수 있어야 하는데 이 때  select, poll, epoll 등이 활용된다.

## Reference

- https://www.baeldung.com/cs/async-vs-multi-threading
 - https://jayhyun-hwang.github.io/2021/09/02/The-Difference-Between-Asynchronous-And-Multi-Threading/
