---
title: Streaming Systems Study
date: 2024-07-02T11:30:00
aliases: 
tags:
  - book
  - study
  - stream
  - streaming
  - batch
categories: 
description: 
updated: 2025-01-07T00:32
---

## 1부. 빔모델

## 스트리밍 101

- [Streaming 101: The world beyond batch – O’Reilly](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)
- [Figures: Streaming Systems Book](http://streamingbook.net/fig)

스트리밍 데이터 처리가 주목받는 이유

- 스트리밍으로 전환하면 시기적절한 통찰력을 빠르게 얻을 수 있다
- 무한 데이터셋이 점점 더 보편화
- 데이터가 도착하는 시점에 처리될 수 있으면 작업 부하가 고르게 분산되어 시스템 자원을 예측 가능한 형태로 소비하는데 도움이 된다

### 스트리밍이란

> [!NOTE]
> 저자는 잘 설계된 **스트리밍 시스템이 기존의 모든 배치 시스템과 마찬가지로 정확하고 일관적이며 반복 가능한 결과를 생성할 수 있고 기술적으로 더 낫다**고 주장하고 있다.

> 무한 데이터셋을 염두에 두고 설계된 데이터 처리 엔진의 유형

용어를 정확하게 사용하자.

데이터셋의 모양을 정의하는 두 가지 중요한 차원

- 기수(cardinality): 데이터셋의 크기, 기수의 가장 두드러진 측면은 지정된 데이터 집합이 유한인지 무한인지를 결정
- 구성 (constitution)

이 두 속성은 직교적(othogonal)이다.

데이터셋의 기수를 설명할 때 사용하는 두 용어

- 유한 데이터
- 무한 데이터

기수가 중요한 이유는 무한 데이터셋의 무한함이라는 특성으로 인해 데이터를 처리하는 데이터 처리 프레임워크가 갖게 되는 부담이 발생하기 때문.

### 심하게 과장된 스트리밍의 한계

#### 람다 아키텍처

> 동일한 계산을 수행하는 배치 시스템과 스트리밍 시스템을 함께 운영하는 것

스트리밍 시스템은 낮은 지연시간으로 부정확한 결과를 제공하며, 얼마 후 배치 시스템을 통해 최종적으로 정확한 결과를 보여준다.

그러나 독립된 두 버전의 파이프라인을 구축하고 유지해야 하며 최종엔 두 파이프라인에서 나온 결과를 병합해야 했기 때문에 람다 시스템을 유지하는 것은 번거로울 수밖에 없다.

#### 새로운 주장

> 배치 시스템은 기능상 잘 설계된 스트리밍 시스템의 엄격한 부분집합에 불과하다고 생각한다.

효율성 면에서 발생하는 차이를 제외하면 오늘날 배치 시스템은 더 이상 쓸 이유가 없다.

> [!NOTE] 배치 시스템은 더 이상 쓸 필요가 없는가
> 다소 공격적인 표현이지만 어느 정도 공감할 수 있었다. 배치를 만들다보면 이거 스트림 처리로도 가능하지 않나 싶은 포인트들을 느낀 적이 종종 있다.

- 무한 데이터 처리를 위해 강력한 프레임워크와 결합된 스트리밍 시스템이 광범위하게 성숙해 감에 따라, 람다 아키텍처는 빅데이터 역사에서 유물로 전락해갈 것

다음은 스트리밍 시스템이 배치 시스템을 이기기 위해 필요한 두 가지

##### 정확성 (correctness)

- 배치와 동등해지기 위해 필요한 조건
- 핵심은 일관성을 제공할 수 있는 스토리지
- 스파크 스트리밍이 일관성 지원이 가능함을 보여줌
- 강한 일관성은 '정확히 한 번 처리 방식'을 지원하기 위해서 반드시 필요
- ? 정확성 = 일관성

##### 시간 판단 도구 (tools for reasoning about time)

- 스트리밍이 배치의 능력을 뛰어넘을 수 있게 해주는 부분
- ? 무한 비순서 데이터를 처리할 때 반드시 필요

### 이벤트 시간 대 처리 시간

- 이벤트 시간: 이벤트가 실제 발생한 시간
- 처리 시간: 이벤트가 처리 시스템에서 관측된 시간

이벤트 시간과 처리 시간이 같은 것이 이상적이지만, 다음과 같은 이유로 사실상 매우 어렵다.

- 공유된 리소스로 인한 제약
- 분산 시스템의 로직, 경쟁 상황 같은 소프트웨어 상의 원인
- 데이터 자체의 특성들 - 키 분산, 전달되는 데이터 양이나 순서의 변화

무한 데이터셋의 무한함이라는 특성을 다루기 위해 윈도우라는 개념으로 잘라서 다루는 개념이 도입되었다. 이 방법은 몇가지 문제를 만들 수 있다.

- 잘못된 처리시간 윈도우로 들어가 정확성에 문제가 생길 수 있다.
- 순서가 보장되지 않고 가변적인 왜곡이 발생할 수 있다
- 데이터의 완결 시점을 예측할 수 없다

### 데이터 처리 패턴

#### 유한 데이터

- 모델 자체가 단순
- 단순한 배치로 처리 가능

#### 무한 데이터: 배치

- 무한 데이터를 배치 처리에 적합한 유한 데이터셋의 집합으로 분할하는 것이 중요

##### 고정 윈도우

- 특정 기준으로 입력 데이터를 고정된 크기의 윈도우로 나눈 후 각 윈도우를 유한 데이터 소스인 것처럼 처리하는 것
- 로그 같은 입력 소스의 경우 이벤트 시간 윈도우로 적절히 분류할 수 있기 때문에 간단하다
- 파티션으로 나누어졌을때 일부가 처리 지연되는 경우 처리가 어려울 수 있다.
    - 모든 이벤트 수집이 완료될 때까지 처리를 지연하거나, 전체 배치 재실행하는 등의 방법을 고려해야 한다

##### 세션

- 특정 세션의 활동 기간 등 더 정교한 전략으로 무한 데이터를 처리할 수 있다.
- 윈도우 경계에서 세션이 끊어진 것처럼 보일 수 있다.
- 세션 단절 문제를 막기 위해 윈도우 사이즈를 늘리면 처리 지연 시간이 늘어날 수 있다.
- 세션을 묶어주고자 하면, 로직의 복잡도가 증가한다.

#### 무한 데이터: 스트리밍

다음과 같은 특성

- 무한한 데이터 입력
- 이벤트 시간 기준으로 뒤섞여, 시간을 기준으로 처리하려면 파이프라인에서 시간 기반의 셔플을 수행해야 하는 데이터
- 이벤트 타임 왜곡이 발생해 특정 시간 범위 안의 데이터의 대부분을 관측했다고 확신할 수 없는 데이터

이와 같은 특성의 데이터를 다룰 때 취할 수 있는 몇 가지 접근법

- 시간 무시 (time-agnostic)
- 근사 (approximation)
- 처리 시간 윈도우 (processing time window)
- 이벤트 시간 윈도우 (event time window)

##### 시간 무시

> 데이터 처리에 시간이 본질적으로 무관한 경우

- 필터링
- 내부 조인
    - 한 소스로부터 값을 확인하고 버퍼링 해둔 뒤 두번째 소스가 도착하면 조인 결과를 생성하는 방식
    - 짝을 만나지 못한 부분적인 결과를 정리하기 위한 가비지 컬렉션 정책이 필요할 수 있다

##### 근사 알고리즘

- 얻고자 하는 결과와 비슷한 결과를 생성하는 방식
- 설계상 낮은 오버헤드를 갖고 무한 데이터를 고려해 설계되었다
- 알고리즘의 종류가 많지 않고, 종종 알고리즘 자체가 복잡
- 근사적인 특성으로 인해 유용성이 떨어질 수 있다
- 보통 설계에 시간적인 요소를 포함한다
    - 증명가능한 오차 범위를 제공하는 알고리즘의 경우 특히 중요
    - 오차 범위가 '데이터는 발생 순서대로 도착한다'는 사실에 기반할 경우, 시간 왜곡이 있는 비순서 데이터에 적용할 때 오차 범위는 본질적으로 무의미하다
- 시간 무시의 한 예

##### 윈도우

> 유한 또는 무한 데이터 소스를 가져와 처리를 위해 시간 경계를 따라 유한한 크기의 조각으로 자르는 개념

- 고정 윈도우
- 슬라이딩 윈도우
- 세션 윈도우
    - 비정렬 윈도우
    - 실제 들어오는 데이터에 따라 길이가 정해지는 동적 윈도우

###### 처리시간 윈도우

> 특정 시간에 따라 들어오는 데이터를 모아둔 후, 관찰된 모든 데이터를 묶어 다음 처리를 위해 보낸다

- 단순
- 윈도우가 완료되는 시점을 판단하기 쉬움
- 데이터 소스가 관측되는 시점을 기준으로 정보를 추론하고자 하는 경우 적합
- 이벤트가 생성된 시간과 서버에서 관측된 시간이 차이가 난다면 유의미한 결과를 내기 어려울 수 있다
    - 모바일 장비에서 비행기 모드 상태였다가 나중에 온라인으로 전환되면서 쌓였던 로그를 한 번에 보내는 경우
- 분산된 입력 소스일 경우에도 시간 왜곡을 갖게 될 수 있다

###### 이벤트 시간 윈도우

> 이벤트가 실제 발생한 시간을 반영해 유한한 크기의 조각으로 데이터 소스를 관찰하고자 할 때 사용

- 이벤트 시간에 대한 정확성 제공
- 세션 같은 동적인 크기를 갖는 윈도우를 만들 수 있다
    - 세션을 임의로 분할해야하는 상황을 피할 수 있다
- 윈도우의 수명이 길어짐에 따라 더 많은 데이터를 **버퍼링**할 필요가 생긴다
- 주어진 윈도우에 대한 모든 데이터를 언제 다 볼 수 있는지 알 수 없다면 윈도우의 결과가 언제 구체화될지 알 수 없다 => **완결성** 문제

## 데이터 처리의 무엇을, 어디서 언제

- ? 워터마크는 정확히 무엇일까
- ? 데이터 셋 중 이벤트 시간이 없거나, 정확하지 않은 경우가 많은가

[Streaming 102: The world beyond batch – O’Reilly](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-102/)

사용자 위치를 10초마다 모바일에 저장 후 네트워크로 전송하는 네비게이션 앱이 있다고 하자. 만약 모바일 기기가 터널 안을 지나고 있을 경우, 네트워크 송신이 지연되어 모바일에 쌓이다가, 한 꺼번에 전송되는 경우가 있을 수 있을 것 같다. 근데 만약, 서버 측에서 사용자 위치 정보를 실시간으로 수집하고 분석하는 스트리밍 시스템이 있다고 할 때, 이런 데이터는 어떻게 다룰 수 있을까

---

## 3장. 워터마크

#watermark

- ? 워터마크는 데이터 생성 시점에 표시하는 이벤트 타임인가?
    - @ 워터마크는 아직 완료되지 않은 작업 중 가장 오래된 작업이 갖는 단조 증가 타임스탬프
    - 이벤트 데이터가 지연되더라도 처리하기 위해서 '이만큼은 대기하겠다'고 명시적으로 선언하는 시간 범위?
    - 혹은 현재 데이터를 처리 중인 이벤트 타임 시간 범위를 선언한 것? 예) 19시5분10초~19시5분15초 범위를 처리 중
    - 그렇다면 워터마크가 뒤로 진행할 수 없다는 것도 이해는 됨
    - & 현재 시간은 11시 9분, 2분 윈도우로 데이터를 처리한다면 11시 8분~11시 10분 윈도우로 처리 중이다. 만약 이 시점에 11시 3분의 데이터가 지연되어 들어온다면 어떻게 해야하는가? 기다려야할까? 2시간이고 3시간이고? 스트리밍 시스템에서는 데이터의 지연을 어느 정도까지 허용할 지 가상의 경계를 그어야하며, 이 개념이 워터마크
    - 배치에서는 기본적으로 데이터셋이 갖춰진 상태에서 실행되므로 워터마크 개념이 없다고 생각한다.
- 완벽한 워터마크, 휴리스틱 워터마크
    - 완벽한 워터마크는 데이터의 처리 지연을 감수하고서라도 모든 데이터 처리를 보장하려 한다
    - 휴리스틱은 어느 정도 지연된 데이터가 있을 수 있음을 인정하고, 누락시킨다?
- ? 데이터를 생성할 때 이벤트 생성 시간을 함께 포함하고 입력 소스로 전달하면 완벽한 워터마크를 만들 수 있는거 아닌가?
- 휴리스틱 워터마크는 워터마크보다 이른 이벤트 시간을 갖는 데이터를 만날 가능성이 적다는 추정에 대한 워터마크를 생성한다.
- 시간순으로 정렬된 동적 로그 데이터, 구글 클라우드 pub/sub 같은 경우는 정확한 휴리스틱 워터마크 생성 가능
- 오프라인 기기가 온라인 상태가 되었을 때 지연된 데이터는 별개의 파이프라인을 통해 처리해야하는가
- 왜 워터마크가 전파되는가
    - 전파 설명으로만 보면 마치 spanId 를 전파하는 것을 통해 트랜잭션을 로깅하려는 과정과 비슷해보인다

## 4장. 고급 윈도우

- 웹서비스의 초당 쿼리수처럼 모니터링을 하는 경우 인입되는 데이터스트림을 관측 시점을 기점으로 분석할 필요가 있다. 이 경우 처리 시간 윈도우가 적합하다.
- 결제, 점수 분석처럼 이벤트가 발생한 시점이 중요한 경우에는 처리 시간 윈도우를 사용해서는 안된다.

- 위 두 케이스 모두 이벤트가 발생한 시점이 중요한게 아닌가? 초당 쿼리수는 쿼리 발생 시점이 아닌가?
    - 쿼리가 실행 중인 경우에 이벤트를 관측해도 상관이 없는 경우인가
    - @ **처리 시간은 처리하는 장비의 시스템 시계 기반 시간**, 이벤트 시간은 실제 이벤트 발생 시간
    - 일반적으로 메세지 브로커는 이벤트를 즉시 전송하지 않고, 모아서 한 번에 전송함. 이로 인해 버퍼에 대기하게 되는 이벤트들이 생기고 필연적으로 이벤트 시간과 처리 시간에 딜레이가 생김. 책에서 말하는 처리 시간은 스트리밍 시스템이 데이터를 관측한 시간.
- 세션별 윈도우는 데이터 건당 세션을 추적해야할까
    - 세션이 끝나는 시점은 윈도우 시작 시점에는 알 수 없기 때문에, 데이터가 어떤 세션과 관련된건지 추적할 필요가 있을 듯

[2.4.4 Streaming Window | practical-data-pipeline](https://1ambda.gitbook.io/practical-data-pipeline/02-processing/2.4-stream/2.4.4-streaming-window)
    
### Reference

- [스트림 프로세싱의 긴 여정을 위한 이정표 (w. Apache Flink) | by scalalang2 | 취미로 논문 읽는 그룹 | Medium](https://medium.com/rate-labs/%EC%8A%A4%ED%8A%B8%EB%A6%BC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1%EC%9D%98-%EA%B8%B4-%EC%97%AC%EC%A0%95%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B4%EC%A0%95%ED%91%9C-with-flink-8e3953f97986)
- [Understanding Watermarking and Late Data in Data Streaming | by Pavitra Gupta | Medium](https://medium.com/@guptapavitra/understanding-watermarking-and-late-data-in-data-streaming-2b2e67bded36)
