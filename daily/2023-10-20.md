---
title: 2023-10-20
date: 2023-10-20 17:16:00 +0900
aliases: 
tags:
  - daily
categories: Daily
updated: 2023-10-20 17:50:07 +0900
---

[[Java Virtual Machine|JVM]] 의 동작 과정

1. .java 파일을 .class 파일로 javac 가 컴파일한다.
2. class loader 는 .class 파일을 동적으로 로드하고 JVM 의 메모리 영역인 Runtime Data Area 에 적재하는 작업을 수행한다.
3. 클래스를 메모리에 올리는 loading 기능은 한 번에 수행되는게 아니라 애플리케이션에서 필요한 경우 적재된다.
4. 클래스 내의 static 멤버들 또한 애플리케이션 실행 시점에 메모리에 적재되는 것이 아니라 클래스 내의 멤버가 호출되면 그 때서야 클래스가 동적으로 로드된다.
5. 아무리 static 멤버들이 있더라도 사용되지 않으면 로드되지 않는다는 것이다.
6. 클래스 내부의 static 멤버를 호출하면 클래스를 인스턴스화 하지 않더라도 클래스가 로드된다.
7. 단, static final 변수를 호출할 경우는 클래스가 로드되지 않는다. 왜냐하면 상수는 JVM method area 의 constant pool 에서 별도로 관리되기 때문이다.
8. 내부 클래스를 생성하기 위해서는 외부 클래스를 먼저 생성하고 인스턴스화해야하기 때문에 외부 클래스와 내부 클래스가 모두 로드된다. 이러한 특징 때문에 내부 클래스를 static 으로 선언하지 않고 사용하면 메모리 누수가 발생하게 된다.
9. static 내부 클래스는 외부 클래스를 생성하지 않고도 직접 인스턴스화가 가능하다. 그래서 일반 내부 클래스와는 달리 외부 클래스를 로드하지 않는다.
10. 클래스 초기화는 클래스 내부의 static 멤버 변수에 값을 할당하는 것을 의미한다. 꼭 `new` 생성자로 클래스를 인스턴스화해야 초기화되는 것은 아니다. 6번에서 살펴봤듯이 생성하지 않아도 static 멤버를 호출하면 클래스가 메모리에 로드되어 초기화가 수행된다.
11. 클래스 초기화는 오직 한 번만 수행된다. 클래스 로딩이 최초로 수행될 때 그 때 한 번만 초기화를 수행하고 나머지는 스킵된다. 멀티 스레드 환경에서 클래스 초기화 동작 자체는 스레드 세이프함을 의미한다.
