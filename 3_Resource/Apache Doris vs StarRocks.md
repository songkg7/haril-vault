---
title:
date: 2025-12-03T12:55:55+09:00
aliases:
tags:
  - doris
  - starrocks
  - datalake
description:
updated: 2025-12-03T12:59
---
- [[Apache Doris]]
- [[StarRocks]]
- [Detailed Comparison Between StarRocks and Apache Doris \| by StarRocks Engineering \| StarRocks Engineering \| Medium](https://medium.com/starrocks-engineering/detailed-comparison-between-starrocks-and-apache-doris-81ddd34be527)

# Apache Doris와 StarRocks: 차세대 OLAP 아키텍처의 분기와 진화에 대한 심층 비교 분석 보고서

## 1. 서론: MPP 데이터베이스의 캄브리아기 대폭발과 두 거인의 탄생

현대 데이터 분석 아키텍처의 지평은 지난 10년 동안 급격한 변화를 겪어왔습니다. 하둡(Hadoop) 기반의 배치(Batch) 처리 시대가 저물고, 실시간성과 대화형(Interactive) 쿼리 성능이 비즈니스의 핵심 경쟁력으로 부상하면서, 대규모 병렬 처리(MPP, Massively Parallel Processing) 데이터베이스가 데이터 플랫폼의 중심축으로 자리 잡았습니다. 이 흐름의 중심에는 Apache Doris와 StarRocks라는 두 개의 거대한 오픈 소스 프로젝트가 존재합니다. 이들은 동일한 뿌리에서 시작되었으나, 현재는 서로 다른 철학과 기술적 지향점을 가지고 경쟁하며 OLAP(Online Analytical Processing) 기술의 한계를 갱신하고 있습니다.

본 보고서는 단순한 기능 비교를 넘어, 두 시스템의 역사적 기원부터 아키텍처의 심층적인 차이, 쿼리 최적화기(Optimizer)의 진화, 스토리지 엔진의 메커니즘, 그리고 데이터 레이크하우스(Data Lakehouse) 전략에 이르기까지 전방위적인 비교 분석을 수행합니다. 150개 이상의 기술 문서, 벤치마크 결과, 커뮤니티 논의 및 릴리스 노트를 종합하여, 데이터 아키텍트와 엔지니어링 리더들이 각자의 워크로드에 최적화된 솔루션을 선택할 수 있도록 명확한 가이드를 제시하는 것을 목표로 합니다.

### 1.1 분석의 배경 및 목적

데이터 엔지니어링 커뮤니티에서 Apache Doris와 StarRocks의 비교는 끊임없이 제기되는 주제입니다. 두 프로젝트 모두 MySQL 프로토콜과 호환되며, 고성능 컬럼 기반 스토리지(Columnar Storage)를 사용하고, 벡터화된 실행 엔진(Vectorized Execution Engine)을 탑재하고 있다는 공통점이 있습니다. 그러나 세부적인 구현 단계로 들어가면, 조인(Join) 처리 방식, 데이터 업데이트 메커니즘, 데이터 레이크 연동성, 그리고 거버넌스 모델에서 현격한 차이를 보입니다. 본 보고서는 이러한 미세한 차이가 실제 운영 환경에서 어떠한 성능적, 운영적 차이를 만들어내는지를 규명합니다.

---

## 2. 역사적 기원과 프로젝트 분기의 기술적, 전략적 맥락

두 시스템의 아키텍처적 차이를 이해하기 위해서는 그들의 탄생 배경과 결별의 역사를 면밀히 살펴볼 필요가 있습니다. 이는 단순한 프로젝트 관리의 문제가 아니라, 기술적 부채를 해결하기 위한 접근 방식의 근본적인 차이에서 기인했기 때문입니다.

### 2.1 Palo 프로젝트와 Apache Doris의 인큐베이팅

모든 것의 시작은 중국의 검색 엔진 거인 바이두(Baidu)의 내부 프로젝트인 'Palo'였습니다. 2010년대 초반, 하둡 기반의 SQL 엔진들이 가진 높은 지연 시간(Latency)과 낮은 동시성(Concurrency) 문제를 해결하기 위해 시작된 Palo는 구글의 Mesa와 Apache Impala의 아키텍처에서 영감을 받아 설계되었습니다.1 Palo는 2017년 오픈 소스로 공개되었고, 2018년 Apache Software Foundation(ASF)에 기증되어 **Apache Doris**라는 이름으로 인큐베이팅을 시작했습니다.1

이 시기의 Doris는 안정적인 MPP 아키텍처를 제공했지만, 실행 엔진의 현대화라는 과제를 안고 있었습니다. 당시의 실행 엔진은 행(Row) 기반 처리 방식이 혼재되어 있었고, 최신 CPU의 SIMD(Single Instruction, Multiple Data) 명령어를 충분히 활용하지 못하는 한계가 있었습니다.

### 2.2 DorisDB의 등장과 StarRocks로의 재탄생

2020년, Apache Doris의 핵심 개발자 중 일부가 프로젝트의 발전 속도와 기술적 방향성에 이견을 가지고 독립을 선언했습니다. 이들은 기존 Doris 코드베이스의 약 90%를 재작성하여 완전히 새로운 엔진을 만들겠다는 목표를 세웠습니다.1 초기에는 'DorisDB'라는 이름으로 활동했으나, 이는 Apache 재단의 상표권 정책과 충돌을 빚었고, 결국 **StarRocks**라는 이름으로 리브랜딩하게 됩니다.1

StarRocks 팀(CelerData)은 "단순한 포크(Fork)가 아닌 재창조"를 주장했습니다. 그들은 기존 Doris의 쿼리 엔진이 10년 전 기술인 Apache Impala에 기반하고 있어 현대적인 분석 워크로드에는 부적합하다고 판단했습니다. 따라서 실행 엔진과 옵티마이저를 바닥부터 다시 설계하여, 단일 테이블 성능뿐만 아니라 복잡한 다중 테이블 조인 성능을 극대화하는 데 집중했습니다.4

### 2.3 "같은 나무에서 자란 다른 색의 잎"

Apache Doris 커뮤니티는 StarRocks를 "같은 나무에서 자란 다른 색의 잎"이라고 표현하며, 두 프로젝트의 유사성을 인정하면서도 상호 발전을 강조합니다.3 그러나 실제로는 시간이 지날수록 두 프로젝트의 지향점은 명확히 갈라지고 있습니다.
- **StarRocks:** "속도"와 "통합"에 집중하며, Trino나 ClickHouse를 대체하는 고성능 데이터 레이크 쿼리 엔진으로서의 입지를 강화하고 있습니다.
- **Apache Doris:** "범용성"과 "사용 편의성"에 집중하며, 로그 분석(Log Analysis), 데이터 웨어하우스, 데이터 레이크를 아우르는 통합 데이터 플랫폼으로 진화하고 있습니다.

---

## 3. 아키텍처 코어: 컴퓨트 및 실행 엔진의 진화

두 데이터베이스의 성능 격차가 발생하는 가장 근본적인 지점은 실행 엔진(Execution Engine)입니다. CPU의 발전 속도를 소프트웨어가 어떻게 따라잡느냐가 현대 데이터베이스의 핵심 과제이며, 두 프로젝트 모두 이 부분에 막대한 엔지니어링 리소스를 투입했습니다.

### 3.1 벡터화 실행 엔진 (Vectorized Execution Engine)

전통적인 데이터베이스는 쿼리를 처리할 때 한 번에 한 행(Row)씩 함수를 호출하는 'Volcano Iterator' 모델을 사용했습니다. 이는 함수 호출 오버헤드가 크고 CPU 캐시 적중률(Cache Hit Rate)이 낮아 비효율적입니다. 이를 해결하기 위해 등장한 것이 벡터화(Vectorization) 기술입니다.

#### StarRocks의 선도적 도입

StarRocks는 프로젝트 초기부터 100% 벡터화된 엔진을 목표로 설계되었습니다. C++로 작성된 이 엔진은 최신 CPU의 AVX512 명령어 세트를 적극적으로 활용하여, 한 번의 CPU 명령으로 여러 데이터 포인트(Column Batch)를 동시에 처리합니다.5 StarRocks는 스토리지 계층에서 메모리로 데이터를 로드하는 순간부터 최종 결과를 반환할 때까지 전 과정이 컬럼(Column) 단위로 처리되도록 파이프라인을 최적화했습니다. 이는 특히 집계(Aggregation)와 필터링 연산에서 극적인 성능 향상을 가져왔습니다.4

#### Apache Doris의 추격과 완성

Apache Doris는 초기에는 벡터화 도입이 부분적으로 이루어졌으나, 버전 1.2를 거쳐 2.0에 이르러서는 기존의 행 기반 실행 코드를 완전히 제거하고 전면적인 벡터화를 달성했습니다.7 Doris 팀은 단순히 연산만 벡터화한 것이 아니라, 데이터가 스토리지에서 메모리로 적재되는 포맷 자체를 벡터 연산에 최적화하여 메모리 복사를 최소화하는 방향으로 발전했습니다. 현재 시점에서 두 엔진 모두 명령어 수준의 병렬성(Instruction-Level Parallelism)을 극대화하고 있어, 순수 벡터화 기술 자체의 격차는 거의 해소된 상태입니다.

### 3.2 파이프라인 실행 모델 (Pipeline Execution Model)

벡터화가 "어떻게 계산하느냐"의 문제라면, 파이프라인 실행 모델은 "언제 계산하느냐"의 문제입니다. 멀티 코어 CPU 환경에서 수천 개의 쿼리가 동시에 들어올 때, 스레드(Thread)를 어떻게 스케줄링하느냐가 전체 처리량(Throughput)을 결정합니다.

#### StarRocks의 파이프라인 엔진

StarRocks는 쿼리를 더 작은 실행 단위인 '파이프라인'으로 쪼개고, 이를 고정된 수의 스레드 풀에서 비동기적으로 실행하는 모델을 채택했습니다.9 이 방식은 쿼리가 디스크 I/O나 네트워크 통신을 기다려야 할 때(Blocking), 해당 스레드를 즉시 다른 작업에 할당함으로써 CPU 유휴 시간을 최소화합니다. 이는 'Morsel-Driven Parallelism'과 유사한 개념으로, StarRocks가 높은 동시성 상황에서도 안정적인 성능을 유지하는 비결 중 하나입니다.

#### Apache Doris의 대응

Apache Doris 역시 버전 2.0부터 파이프라인 실행 엔진을 기본으로 채택했습니다.8 Doris의 파이프라인 엔진은 복잡한 쿼리 시나리오에서 테넌트 간의 리소스 격리를 강화하고, 특정 쿼리가 CPU를 독점하는 것을 방지하는 스케줄링 알고리즘에 강점을 보입니다.

---

## 4. 쿼리 최적화기(Optimizer): 시스템의 두뇌 싸움

데이터베이스 성능의 50%가 실행 엔진에서 나온다면, 나머지 50%는 쿼리 최적화기에서 나옵니다. 특히 조인(Join)이 많은 복잡한 쿼리에서 최적화기의 성능은 절대적입니다.

### 4.1 StarRocks의 비용 기반 최적화기 (CBO)

StarRocks는 초기부터 **비용 기반 최적화기(CBO, Cost-Based Optimizer)** 개발에 사활을 걸었습니다. StarRocks의 CBO는 테이블의 통계 정보(행 수, 컬럼의 카디널리티, 데이터 분포 등)를 수집하여 수억 가지의 실행 계획 중 가장 비용이 적게 드는 계획을 선택합니다.1

- **조인 순서 재정렬(Join Reordering):** StarRocks CBO의 가장 강력한 기능은 다중 테이블 조인 시 테이블의 순서를 동적으로 변경하는 능력입니다. 예를 들어, 작은 테이블을 먼저 필터링하여 데이터 양을 줄인 후 큰 테이블과 조인하도록 계획을 수정함으로써 메모리 사용량을 줄이고 속도를 높입니다.
- **탈정규화(Denormalization) 불필요:** StarRocks는 이 강력한 CBO 덕분에 사용자가 굳이 성능을 위해 테이블을 하나로 합치는 '플랫 테이블(Flat Table)' 작업을 하지 않아도 된다고 주장합니다. "Join on the fly" 즉, 쿼리 시점에 조인을 해도 충분히 빠르다는 것이 그들의 핵심 가치 제안입니다.5
    

### 4.2 Apache Doris의 네레이드(Nereids) 최적화기

오랫동안 Apache Doris는 구형 옵티마이저에 의존하여 복잡한 조인 성능에서 약점을 보였습니다. 그러나 버전 2.0에서 **네레이드(Nereids)** 라는 차세대 옵티마이저를 도입하며 판도를 뒤집었습니다.8

- **Cascades 프레임워크:** Nereids는 현대적인 최적화 프레임워크인 Cascades를 기반으로 구축되었습니다. 이는 쿼리 변환 규칙을 모듈화하여 관리하기 쉽고, 탐색 공간을 효율적으로 가지치기(Pruning)하여 최적의 계획을 빠르게 찾아냅니다.
- **TPC-DS 100% 커버리지:** Nereids 도입 이후 Apache Doris는 TPC-DS 벤치마크의 모든 99개 쿼리를 수정 없이 실행할 수 있게 되었으며, 이는 이전 버전에 비해 10배 이상의 성능 향상을 가져왔습니다.8
- **힌트(Hint) 및 제어:** Doris는 옵티마이저가 실수를 할 경우를 대비해 `Leading Hint`(조인 순서 강제), `Distribute Hint`(데이터 분산 방식 강제) 등 강력한 힌트 기능을 제공하여 DBA가 쿼리 계획을 미세 조정할 수 있는 권한을 부여합니다.12
    

**[표 1] 쿼리 최적화기 비교**

| **특징**      | **StarRocks CBO**            | **Apache Doris Nereids**            |
| ----------- | ---------------------------- | ----------------------------------- |
| **기반 아키텍처** | 자체 개발 CBO                    | Cascades Framework 기반               |
| **주요 강점**   | 다중 테이블 조인 재정렬, 성숙도 높음        | 빠른 개발 속도, 힌트(Hint) 지원, 확장성          |
| **통계 수집**   | 자동 수집 및 히스토그램 지원             | 자동 수집, 런타임 필터(Runtime Filter) 강력 지원 |
| **지향점**     | 정규화된 스키마(Star Schema)에서의 고성능 | 표준 SQL 호환성 및 극한의 튜닝 유연성             |

---

## 5. 스토리지 엔진과 실시간 데이터 처리 (Real-Time Mutability)

OLAP 시스템에서 데이터를 실시간으로 수정(Update/Delete)하는 것은 매우 비용이 많이 드는 작업입니다. 두 시스템은 이 문제를 해결하기 위해 서로 다른 전략을 취했습니다.

### 5.1 StarRocks의 프라이머리 키(Primary Key) 모델

StarRocks는 실시간 갱신이 빈번한 시나리오를 위해 **프라이머리 키 모델**을 도입했습니다.2

- **Delete Vector 메커니즘:** 기존의 'Merge-on-Read' 방식은 쿼리 시점에 여러 버전의 데이터를 병합해야 해서 느렸습니다. StarRocks는 업데이트가 발생할 때 구버전 데이터를 물리적으로 삭제하는 대신, 메모리에 있는 'Delete Vector'에 삭제 표시를 하고 새 데이터를 씁니다. 쿼리 시에는 이 벡터만 확인하면 되므로 읽기 성능 저하가 거의 없습니다.6
- **메모리 사용량 이슈:** 이 방식은 매우 빠르지만, 프라이머리 키 인덱스가 메모리를 많이 차지할 수 있습니다. 따라서 StarRocks는 프라이머리 키 컬럼의 크기를 제한(기본 128바이트)하고, 대용량 데이터의 경우 인덱스를 디스크에 저장하는 영구 인덱스(Persistent Index) 기능을 권장합니다.14

### 5.2 Apache Doris의 유니크 키(Unique Key)와 Merge-on-Write

Apache Doris는 전통적으로 유니크 키 모델에서 'Merge-on-Read'를 사용했으나, 버전 1.2부터 **Merge-on-Write** 방식을 도입하여 성능을 비약적으로 향상시켰습니다.6

- **쓰기 시점 병합:** 데이터가 입력되는 시점에 중복 키를 확인하고 병합을 수행하여, 쿼리 시점에는 최신 상태의 데이터만 읽게 합니다. 이는 쓰기 성능에 약간의 오버헤드를 주지만, 읽기 성능은 불변(Immutable) 데이터 테이블과 동일한 수준으로 끌어올립니다.
- **역색인(Inverted Index)의 통합:** Doris의 가장 큰 차별점은 모든 컬럼에 대해 **역색인(Inverted Index)** 을 생성할 수 있다는 점입니다. 이는 텍스트 검색이나 특정 조건의 필터링(Point Query) 속도를 획기적으로 높여주며, 특히 로그 분석 시나리오에서 StarRocks 대비 압도적인 성능을 발휘합니다.16

---

## 6. 데이터 레이크하우스(Lakehouse) 전략: 개방형 생태계의 패권 다툼

이제 데이터는 데이터 웨어하우스 안에만 갇혀 있지 않습니다. S3나 HDFS에 저장된 Iceberg, Hudi, Delta Lake 포맷의 데이터를 직접 쿼리하는 '데이터 레이크하우스' 능력이 핵심 경쟁력으로 떠올랐습니다.

### 6.1 StarRocks: 데이터 레이크의 고성능 가속기

StarRocks는 자신을 "데이터 레이크를 위한 최고의 쿼리 엔진"으로 포지셔닝하며, Trino(구 PrestoSQL)를 대체하는 것을 목표로 합니다.1

- **데이터 캐시(Data Cache):** 원격 스토리지(S3 등)의 데이터를 읽을 때, 자주 액세스하는 블록을 로컬 NVMe SSD에 캐싱하는 기술입니다. StarRocks는 이를 통해 네트워크 I/O를 줄이고 로컬 디스크에 준하는 성능을 냅니다.19 이전에는 'Block Cache'로 불렸으나 최신 버전에서는 'Data Cache'로 통합되었습니다.
- **다양한 포맷 지원:** Apache Iceberg(v1/v2), Hudi(COW/MOR), Delta Lake를 모두 지원하며, 특히 Iceberg의 'Time Travel' 쿼리도 지원합니다.21 최근 버전(3.1+)에서는 Iceberg 테이블에 데이터를 쓰는(INSERT INTO) 기능도 추가되었습니다.23

### 6.2 Apache Doris: 통합된 레이크하우스 관리자

Apache Doris는 단순한 쿼리 가속을 넘어 레이크하우스의 관리 및 통합 플랫폼을 지향합니다.

- **멀티 카탈로그(Multi-Catalog) 및 자동 매핑:** Doris 3.0은 외부 데이터 소스의 메타데이터를 자동으로 매핑하는 멀티 카탈로그 기능을 강화했습니다.24
- **파일 캐시(File Cache):** Doris 역시 원격 파일을 1MB 단위로 슬라이싱하여 로컬에 캐싱하는 파일 캐시 메커니즘을 가지고 있습니다. TTL(Time-To-Live) 큐와 인덱스 큐를 분리하여 캐시 적중률을 높이는 알고리즘이 특징입니다.26
- **쓰기(Write-back) 및 ZeroETL:** Doris 3.0은 Hive나 Iceberg 테이블로 데이터를 다시 쓰는 기능을 강력하게 지원합니다. 이는 Doris를 이용해 가공된 데이터를 다시 레이크로 내보내 다른 에코시스템과 공유하는 워크플로우를 가능하게 합니다.27

**[표 2] 데이터 레이크 지원 기능 비교**

| **기능**         | **StarRocks**            | **Apache Doris**                          |
| -------------- | ------------------------ | ----------------------------------------- |
| **캐싱 메커니즘**    | Data Cache (Block Cache) | File Cache (Multi-Queue LRU)              |
| **Iceberg 지원** | Read/Write, Time Travel  | Read/Write, Time Travel, Schema Evolution |
| **주요 타겟**      | Trino 대체 (고성능 쿼리 엔진)     | 통합 데이터 플랫폼 (ZeroETL, 관리)                  |
| **Paimon 지원**  | 읽기 지원                    | 읽기 및 쓰기 강화 (긴밀한 통합)                       |

---

## 7. 구체화된 뷰(Materialized View)와 쿼리 재작성

반복적인 집계 쿼리의 성능을 높이기 위해 구체화된 뷰(MV)는 필수적입니다.

### 7.1 StarRocks의 비동기 MV와 지능형 재작성

StarRocks는 비동기 MV(Asynchronous Materialized View) 분야에서 선도적인 위치를 점하고 있습니다.28

- **투명한 쿼리 재작성(Transparent Query Rewrite):** 사용자가 원본 테이블을 대상으로 쿼리를 날려도, 옵티마이저가 자동으로 적합한 MV를 찾아 쿼리를 바꿔치기합니다. SPJG(Select-Project-Join-Group-by) 형태의 복잡한 쿼리도 인식하여 재작성할 수 있습니다.29
- **다중 테이블 지원:** 초기의 단순 롤업(Rollup)과 달리, 여러 테이블이 조인된 결과도 MV로 만들 수 있어 데이터 마트 구축 비용을 획기적으로 줄여줍니다.

### 7.2 Apache Doris의 추격

Doris는 2.1 버전부터 비동기 MV 기능을 대폭 강화하여 StarRocks와의 격차를 줄였습니다.30

- **파티션 단위 갱신:** 데이터가 변경된 파티션만 식별하여 증분 갱신(Incremental Refresh)을 수행함으로써 MV 유지 비용을 최소화합니다.
- **유연성:** Doris의 MV는 베이스 테이블이 변경되었을 때, 뷰의 데이터와 베이스 테이블의 데이터를 실시간으로 유니온(Union)하여 정확성을 보장하는 옵션도 제공합니다.31

---

## 8. 성능 벤치마크 및 실제 운영 시나리오 분석

벤치마크는 환경에 따라 달라질 수 있지만, 공개된 자료와 커뮤니티의 경험을 종합하면 다음과 같은 패턴이 관찰됩니다.

### 8.1 단일 테이블 및 표준 벤치마크 (TPC-H, ClickBench)

StarRocks는 ClickBench(실시간 분석 벤치마크)와 TPC-H에서 지속적으로 최상위권을 유지하고 있습니다.5 특히 벡터화 엔진의 효율성 덕분에 Trino 대비 3~5배 빠른 성능을 보여줍니다. Apache Doris 역시 최신 버전(2.0 이상)에서는 네레이드 옵티마이저 덕분에 TPC-DS와 같은 복잡한 쿼리셋에서 StarRocks와 대등하거나 특정 시나리오(콜드 런, 데이터 로드)에서 앞서는 모습을 보입니다.1

### 8.2 다중 테이블 조인 (Join Performance)

이 영역은 여전히 **StarRocks**의 우세가 뚜렷한 분야입니다. StarRocks의 CBO와 파이프라인 엔진은 복잡한 스타 스키마나 스노우플레이크 스키마를 별도의 평탄화(Flattening) 작업 없이도 고성능으로 처리합니다.4 이는 데이터 모델링 유연성을 중시하는 조직에게 큰 장점입니다.

### 8.3 고동시성 포인트 쿼리 (High Concurrency Point Query)

**Apache Doris**는 이 분야에서 독보적입니다. 수만 QPS(Queries Per Second)의 동시 요청이 들어오는 사용자 대시보드(Customer 360)나 로그 검색 시나리오에서, Doris의 역색인 기술과 고동시성 처리 아키텍처는 StarRocks보다 낮은 지연 시간을 보장합니다.1 StarRocks는 대규모 집계 분석에 더 최적화되어 있습니다.

---

## 9. 생태계, 운영 편의성 및 거버넌스

기술 외적인 요소인 커뮤니티와 운영 모델 또한 도입 결정의 중요한 변수입니다.

### 9.1 거버넌스 모델: Apache Way vs 벤더 주도

- **Apache Doris:** Apache 재단의 최상위 프로젝트(TLP)로서, 특정 벤더에 종속되지 않는 "Community Over Code" 철학을 따릅니다. 이는 장기적인 안정성과 벤더 락인(Vendor Lock-in) 방지를 중요시하는 기업에게 유리합니다.1
- **StarRocks:** CelerData가 주도하는 프로젝트입니다. 비록 오픈 소스이지만 로드맵과 주요 기능 개발이 회사의 상업적 전략과 밀접하게 연동되어 있어 개발 속도가 빠르고 기술 지원이 명확하다는 장점이 있습니다.1

### 9.2 상용 서비스 및 지원

- **SelectDB (Doris 기반):** SelectDB는 Apache Doris의 상용 버전으로, 클라우드 네이티브 아키텍처와 엔터프라이즈 관리 도구를 제공합니다.34
- **CelerData (StarRocks 기반):** CelerData는 StarRocks의 엔터프라이즈 버전으로, 보안 기능과 전용 관리 콘솔, 그리고 클라우드 매니지드 서비스를 제공합니다.36

---

## 10. 결론 및 전략적 제언

Apache Doris와 StarRocks는 모두 현존하는 최고의 오픈 소스 OLAP 데이터베이스입니다. "어느 것이 더 빠른가?"라는 질문은 이제 의미가 퇴색되었습니다. 두 엔진 모두 대부분의 비즈니스 요구사항을 충족시킬 만큼 충분히 빠릅니다. 진정한 선택의 기준은 **"데이터의 형태"**와 **"쿼리의 성격"**이어야 합니다.

### 10.1 StarRocks를 선택해야 하는 경우

1. **복잡한 조인 중심의 워크로드:** 정규화된 테이블을 그대로 유지하면서 고성능 조인 쿼리를 수행해야 할 때.
2. **데이터 레이크 가속:** 기존의 데이터 레이크(Iceberg/Hudi)를 마이그레이션 없이 즉시 고속으로 분석하고 싶을 때 (Trino 대체).
3. **빠른 기능 업데이트:** 벤더 주도의 공격적인 로드맵과 최신 기술(Data Cache 등)의 빠른 도입이 필요할 때.

### 10.2 Apache Doris를 선택해야 하는 경우

1. **고동시성 및 포인트 쿼리:** 수천 명의 사용자가 동시에 접속하는 대시보드나 특정 ID 조회 서비스(Serving)를 구축할 때.
2. **로그 분석 및 검색:** 텍스트 검색과 SQL 분석을 하나의 시스템에서 통합하여 Elasticsearch 비용을 절감하고자 할 때 (역색인 활용).
3. **오픈 거버넌스:** 특정 벤더에 종속되지 않는 순수 Apache 프로젝트를 선호하며, 안정적인 커뮤니티 지원을 원할 때.
4. **통합 데이터 플랫폼:** 데이터 수집, 가공(ETL), 서빙을 하나의 클러스터에서 수행하며 워크로드 격리(Workload Isolation)가 중요할 때.

결론적으로, StarRocks는 **"분석 성능의 F1 레이싱카"**로서 복잡한 연산과 데이터 레이크 주행에 최적화되어 있으며, Apache Doris는 **"다재다능한 SUV"**로서 고속 주행부터 험로(로그, 비정형 데이터) 주파까지 아우르는 범용성과 안정성을 제공합니다. 조직의 데이터 전략이 '속도와 효율'에 방점이 찍혀있는지, '통합과 범용성'에 있는지에 따라 최적의 선택은 달라질 것입니다.
