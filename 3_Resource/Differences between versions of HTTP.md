---
title: Differences between versions of HTTP
date: 2024-03-11 13:47:00 +0900
aliases: 
tags:
  - http
categories: 
updated: 2024-03-19 17:56:05 +0900
---

HTTP 는 현재 3.0까지 존재한다. 각 버전 별 어떤 차이점이 존재하는지 알아보자.

## HTTP 0.9

HTTP 0.9 는 원시적인 버전으로 현재 사용되는 HTTP와는 거리가 멀다. 이 버전은 단일 요청과 응답을 통해 파일을 전송하였다. 요청의 형식은 다음과 같다.

```
GET /index.html
```

간결하게 보이지만 다음과 같은 제약이 많았다.

- GET 메소드만 지원
- 헤더 정보가 없음
- HTTP 상태 코드가 없음

## HTTP 1.0

HTTP 1.0은 1996년에 정의되었다. 이전의 HTTP 0.9과 차이점을 많이 갖고 있지만, 아직까지 사용되는 가장 큰 차이점은 Persistent Connections를 지원하지 않는다는 것이다.

Persistent Connections란 하나의 요청에 의해 닫히지 않고 여러 개의 응답을 보내주는 기능을 말한다. 이 기능 덕분에 여러 개의 이미지를 한 번에 다운로드 받거나, 다운로드 중인 파일을 모니터링하는 등의 작업에서 높은 효율을 보였다.

### 요청 메시지

HTTP 1.0 에서는 이번에도 GET 메소드만을 사용한다. 그러나 서버에 부가적인 정보를 전달하기 위해 헤더를 추가할 수 있게 되었다. 헤더 정보는 다음과 같이 구성된다.

```
GET /index.html HTTP/1.0
Accept: text/html
Host: www.google.com
```

위 예제에서는 `Accept` 와 `Host` 라는 두 가지 헤더 정보를 전달하고 있다.

### 응답 메시지

응답 메시지에서도 서버가 클라이언트에게 전송하는 데이터에 대한 부가적인 정보를 전달할 수 있게 되었다. 이 정보는 다음과 같이 구성된다.

```
HTTP/1.0 200 OK
Content-Type: text/html

<html>
    <head> ... </head>
    <body> ... </body>
</html>
```

위 예제에서는 `Content-Type` 헤더를 사용해 전달하고 있는 데이터가 어떤 형식의 데이터인지 알려주고 있다. 이외에도 다음과 같은 헤더들이 있다.

- Content-Length
- Expires
- Server

하지만, HTTP 1.0은 그동안 지속적으로 증가했던 웹 페이지 수와 다양한 리소스들을 처리하는 데 부족한 면이 있었다.

## HTTP 1.1

1997년에 발표된 HTTP 1.1에서는 Persistent Connections가 기본적으로 지원하기 시작했다.

또한, Host 헤더가 추가되어 한 IP 주소 내에서 여러 개의 웹 사이트를 운영할 수 있게 되었다.

HTTP 1.1에서는 각 요청마다 연결을 하나씩 만들어서 처리하던 것 대신, 하나의 연결로 여러 요청/응답을 처리할 수 있게 되었다. 이로 인해 동시에 여러 요청을 처리하는 효율성이 향상되었다.

하지만 이로 인해 문제가 발생하기도 했다. 연결을 재사용하는 기능이 생겼지만, 그 연결은 하나의 요청/응답에 대해 새롭게 이루어졌다. 따라서 이미지와 같은 큰 데이터를 주고 받는 경우, 한 개의 이미지를 주고 받는 데 걸리는 시간 만큼 다른 요청들도 전부 블로킹된다.

이 문제를 해결하기 위해 `Pipelining` 기법이 도입되었다. `Pipelining` 은 HTTP 1.0에서 사용하던 방식과 비슷하다. 하지만 HTTP 1.1 에서 명시적으로 지원하도록 정의되어있다.

`Pipelining` 은 여러 개의 요청을 한 번에 보내주기 때문에 보낸 순서대로 응답이 오지 않는 경우, 순서대로 맞춰주기 위해 추가적인 작업을 해줘야 하기 때문에 이전 버전보다 복잡한 구조를 가지고 있다.

## HTTP 2

HTTP 2는 기존의 텍스트 형식으로 데이터를 전송하는 방식 (HTTP/1.x)을 대체하기 위해서 나왔다.

기존 버전과 달리 새로운 포맷인 `binary format` 을 사용한다. `binary format`은 이진수로 이루어져 있기 때문에 기존의 텍스트 데이터보다 더 작은 크기를 가지고 있다.

이러한 `binary format`을 사용하기 때문에 더 적은 양의 데이터를 전송해도 되고, 기존 방식보다 더 빠른 속도로 통신할 수 있다.

또한, HTTP 2는 HTTP 1.1의 `Pipelining` 기능과 비슷하게 여러 요청을 한 번에 보내주는 `Multiplexing` 을 지원한다. 하나의 연결에서 여러 요청/응답을 처리하기 때문에 HTTP 1.1 과 같이 순서대로 맞춰주는 작업이 필요 없다.

HTTP 2에서 문제가 발생하는 경우가 있는데, 바로 서버 측에서 클라이언트와 연결을 유지하는 경우이다. HTTP 2에서는 하나의 연결만으로 모든 요청/응답을 처리하므로 서버 측에서도 여러 개의 연결을 유지하지 않아도 된다. 따라서 서버 측에서 클라이언트와 연결을 유지하는 경우, 다른 요청들도 계속해서 대기하게 되고 이는 성능 저하를 가져올 수 있다.

## HTTP 3

HTTP 3는 HTTP 2와 비슷한 구조를 가지고 있지만, 전송 프로토콜이 다르다. HTTP 2는 TCP 위에서 동작하지만, HTTP 3은 UDP 위에서 동작한다.

HTTP 2에서 발생할 수 있는 `head-of-line blocking` 문제를 해결하기 위해 생긴 기술인 QUIC (Quick UDP Internet Connections) 를 사용한다.


> [!NOTE] HOLB
> TCP 는 패킷이 유실되거나 오류가 있을 때 재전송을 하는데 이 재전송하는 패킷에 지연이 발생하면 이후 패킷이 모두 지연되는 현상

QUIC은 스트림을 사용하여 여러 요청/응답을 처리하므로 `Multiplexing` 과 같은 장점을 가진다. 하지만 스트림이라는 개념으로 인해 이전에 몰랐던 새로운 문제가 발생하기도 한다. 바로 패킷 손실이다. 스트림을 사용하게 되면 하나의 요청/응답 분위기가 서로 상호 의존적이므로, 중간에 패킷 손실이 발생하면 그 이후의 모든 요청/응답도 실패하게 된다는 것이다. 그래서 이러한 문제를 해결하기 위해 기존에 사용되던 [[TCP]]의 기능 중 하나인 재전송 기능을 구현하여 HTTP 3 에서 사용한다.

#quic

## 참고

- [HTTP/3: The Past, The Present, and The Future](https://blog.cloudflare.com/http3-the-past-present-and-future/)
- [HTTP 2.0은 무엇이 좋고 나쁜가](https://blueshw.github.io/2016/02/17/http2-what-is-good-and-bad/)
- https://gngsn.tistory.com/234
- [HTTP 3.0 소개 & 통신 기술 알아보기](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
