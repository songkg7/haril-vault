---
title: 캐시 문제 해결 가이드
date: 2024-02-21 10:54:00 +0900
aliases: 
tags:
  - cache
  - redis
categories: 
updated: 2024-02-21 11:31:27 +0900
---

데이터베이스는 시스템을 확장하기 어렵다. 주로 샤딩과 복제를 통해 어렵게 확장해야 하는데다가, 이 과정에서 일관성, 가용성, 분할 내성 셋을 모두 만족시킬 수 없다는 점이 널리 알려져 있다([[CAP]]). 이러한 이유로 데이터베이스를 확장할 때는 신중한 고민이 필요하다.

가급적 데이터베이스의 부하를 최소화하여 확장 필요성을 줄이는 것이 바람직하다. 이를 위한 기본적인 접근법은 데이터베이스 조회 이전에 캐시(cache)를 먼저 확인하는 것이다. 높은 캐시 히트율을 유지하면 데이터베이스 확장 없이도 상당한 트래픽을 처리할 수 있다.

인메모리 저장소인 [[Redis]]나 Memcached 르 사용해서 캐시 시스템을 구축하는 곳이 많다. 이들 저장소는 사용하기 쉬운 다가 응답속도가 빠르기 때문이다. 특히 레디스를 쓰는 곳이 많은데 레디스는 다양한 활용 사례를 쉽게 찾을 수 있어서 안정적인 운영이 가능하다.

하지만 대용량 트래픽 환경에서 캐시를 사용할 때는 몇가지 주의해야 할 상황들이 있다. 이 글에서는 캐시를 사용함에도 불구하고 데이터베이스 부하로 인해 서비스 장애가 발생할 수 있는 위험 상황들을 설명하고 이를 예방하는 방법을 소개한다.

## 1. 캐시 쇄도 (Cache Stampede)

> 캐시 미스가 동시에 많이 발생할 경우 데이터베이스에 부담이 가중되는 현상

캐시가 전부 정확히 같은 시간에 만료되도록 구현하면 자주 발생한다.

예를 들어 매일 자정에 캐시를 갱신하는 경우를 생각해 보자. 갱신 시간에 맞춰 캐시를 일제히 만료되도록 설계하는 것은 구현하기 쉬운 데다가 최신 정보를 바로 제공할 수 있다는 이점이 있다. 하지만 이런 만료 전략은 캐시가 만료되는 자정마다 데이터베이스로 트래픽이 집중되어 서비스 장애가 발생할 위험이 있다.

### 해결안: 지터 (Jitter)

캐시 만료 시간을 무작위로 약간 지연시키면, 캐시 쇄도 상황에서도 데이터베이스의 부하를 균등하게 분산시킬 수 있다.

서비스마다 허용할 수 있는 지연 시간은 다르기 때문에, 서비스에 맞게 최대 지터 시간을 설정해야 한다. 지터가 길어질수록 사용자는 더 오래된 정보를 볼 수 있으므로, 지터가 과도하게 추가되지 않도록 주의해야 한다.

## 2. 캐시 관통 (Cache Penetration)

> 데이터베이스에서 읽었는데도 캐시되지 않는 상황

캐시에서 `null` 값이 반환되면 자연스럽게 데이터베이스를 조회해서 캐시를 채운다. 그런데 데이터베이스에서도 해당 값이 없어서 `null` 을 반환받았을 때는 캐시를 채우지 않도록 구현하는 경우가 흔하다.

캐시 관통이 빈번하다면, 불필요한 조회 요청이 자주 발생한다. 따라서 데이터가 없다는 사실도 캐싱해야 불필요한 데이터베이스 부하를 줄일 수 있다.

### 해결안: 널 오브젝트 패턴 (Null Object Pattern)

'값이 없음'을 캐싱함으로써 데이터베이스의 트래픽을 줄이기 위해서 [[bloom filter]] 를 사용하는 것도 좋은 방법이다. 하지만 블룸 필터의 정합성이 깨진다면, 블룸 필터를 복구하기 위해 모든 캐시를 읽어야 해서 운영에 어려움이 따른다.

널 오브젝트 패턴을 사용해서 '값이 없음'을 캐싱하는 편이 조금 더 운영하기 쉽다. 객체 타입은 부재를 뜻하는 객체를 선언하여 사용하면 되지만, 원시타입의 경우에는 이 객체를 대체할 특정 값을 지정해야 한다. 예를 들어, 양수만 존재하는 정수 타입의 데이터를 캐시할 때는 음수인 정수의 최솟값으로 '값이 없음'을 나타내기로 애플리케이션에서 약속할 수 있다.

## 3. 캐시 시스템 장애

### 해결안: 대체 작동 (Failover)

## 4. 핫키 (hotkey) 만료

많은 요청이 집중되는 키를 '핫키'라고 부른다. 핫키가 만료되는 순간, 여러 요청이 동시에 데이터베이스를 불필요하게 반복해서 조회할 수 있다. 가능하다면 캐시으 만료 기한을 없애거나, 백그라운드에서 주기적으로 새 값을 적용해서 캐시가 만료되지 않게 하는 것이 좋다. 지만 핫키가 때에 따라 바뀌는 환경에서는 더 이상 핫키가 아닌 데이터로 인해 캐시 저장소 공간이 낭비될 수 있다.

### 해결안: 분산 락 (Distributed Lock)

분산 락을 사용하면 공간 낭비 없이 불필요한 데이터베이스 중복 조회를 방지할 수 있다. 멀티 스레드 프로그래밍에서 공유 자원 다룰 때 락을 사용하는 것과 비슷한 원리다. 캐시를 애플리케이션 서버 간의 공유 자원으로 볼 수 있다. 캐시 미스가 발생했을 때 락을 설정하고 캐싱한 후에 락을 해제함으로써, 단 한 번의 쓰기 작업만 허용할 수 있다.

레디스를 사용하고 있다면 분산 락을 적용하기 굉장히 쉽다.

## Reference

- https://toss.tech/article/cache-traffic-tip
