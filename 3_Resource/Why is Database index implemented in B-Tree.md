---
title: 왜 데이터베이스는 B-tree 를 인덱스 알고리즘으로 사용할까
date: 2023-09-12T20:19:00
aliases: []
tags:
  - b-tree
  - database
  - db
  - index
categories: 
updated: 2025-01-07T00:35
---

### 레드블랙트리와의 비교

> 트리의 시간복잡도 : $Olog(N)$

[[Red-Black Tree]] 나 [[B-Tree]] 모두 밸런스 트리인데 왜 B-Tree 를 사용할까?

RedBlack-Tree 는 하나의 노드에 하나의 데이터를, B-Tree 는 하나의 노드에 여러개의 데이터를 저장한다. 그러므로 같은 양의 데이터를 저장하더라도 B-Tree 는 높이를 더 낮게 유지할 수 있다. 트리의 높이를 낮게 유지하는 것은 트리의 정렬 속도에 영향을 준다.

이론적인 시간 복잡도는 동일하더라도 참조 포인터의 접근 수 때문에 RedBlack-Tree 보다 B-Tree 가 더욱 빠르게 요소를 탐색할 수 있다.

### 배열과의 비교

배열([[Array]])은 참조 포인터라는 개념이 없고 모든 데이터가 메모리 상 차례대로 저장되어 있으므로 배열의 인덱스를 통해 $O(1)$ 으로 데이터를 조회할 수 있다.

하지만 배열이 빠른 것은 조회에만 해당되며, 삽입 또는 삭제 연산이 발생할 경우는 배열 내의 많은 원소들을 재배치해야할 수 있다. 이 경우 배열은 매우 비효율적으로 동작하게 된다.

### 해시테이블과의 비교

해시 테이블은 해시 함수를 통해 도출한 해시값을 이용하여 메모리에 접근하므로 $O(1)$ 의 시간복잡도를 갖는다. 그러나 이것은 하나의 원소를 탐색하는 경우에만 해당된다. 만약 범위 탐색을 수행해야한다면 어떨까? 해시 테이블은 정렬되어 있지 않으므로 부등호 연산에서 매우 비효율적이다. 그렇기에 기준 값보다 크거나 작은 값을 탐색할 수 있어야 하는 인덱스로는 부적절하다.

## Reference

- https://steady-coding.tistory.com/558
