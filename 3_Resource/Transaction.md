---
title: Transaction
date: 2023-08-08 21:48:00 +0900
aliases: 
tags:
  - database
  - acid
  - study
  - book
  - transaction
categories: 
updated: 2024-05-02 20:56:47 +0900
---

## What is Transaction?

A transaction is a series of actions or operations performed within a system or business process that results in a change or transfer of goods, services, or information. It involves the exchange of resources between two or more parties, typically with the aim of achieving a specific goal or objective.

Transactions can occur in various contexts, including financial transactions, business transactions, and computer transactions. In financial terms, a transaction refers to the buying or selling of goods, services, or financial assets such as stocks and bonds. Business transactions involve activities such as purchasing supplies, signing contracts, and making payments.

Computer transactions refer to the execution of commands or operations within a computer system. These can include tasks like data entry, database updates, file transfers, and online purchases.

Transactions are typically characterized by certain key attributes:

1. Atomicity: A transaction is considered atomic if it is treated as a single unit of work that either completes successfully in its entirety or fails completely without any intermediate state being saved.
2. Consistency: A transaction should transform the system from one consistent state to another. It ensures that all constraints and rules governing the system are maintained throughout the transaction.
3. Isolation: Transactions should be executed in isolation from other concurrent transactions to prevent interference and maintain data integrity.
4. Durability: Once a transaction is committed and completed successfully, its changes should be permanent and survive any subsequent failures or system crashes.

Transactions play a crucial role in various industries and sectors by facilitating secure and reliable exchanges of goods, services, information, and funds. They provide accountability and transparency while ensuring that parties involved can trust the outcome of their interactions.

---

# 트랜잭션

- 데이터베이스 소프트웨어나 하드웨어는 (쓰기 연산이 실행 중일 때를 포함해서) 언제라도 실패할 수 있다
- 애플리케이션은 (연속된 연산이 실행되는 도중도 포함해서) 언제라도 죽을 수 있다
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다

트랜잭션은 자연 법칙이 아니며 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.

## 애매모호한 트랜잭션의 개념

### ACID의 의미

- Atomicity (원자성)
- Consistency (일관성)
- Isolation (격리성)
- Durability (지속성)

저자가 해당 원칙의 모호함에 대해 엄청 디스하는 느낌

#### 원자성

시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.

ACID 의 맥락에서 보면 원자성은 동시성과 관련이 **없다**. 원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려고 할 때 무슨 일이 생기는지 설명하지 않는다. 이 내용은 격리성에서 다룬다.

오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 원자성의 결정적인 특징이다. 어보트 능력(abortability)이라고 부르는게 적합하다.

#### 일관성

일관성은 굉장히 여러 의미로 쓰인다.

ACID 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(invariant)이 있다는 것이다. 트랜잭션이 불변식이 유효한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.

그러나 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이며 데이터베이스가 보장할 수 있는 게 아니다.

원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 (ACID에서의) 일관성은 애플리케이션의 속성이다. 따라서 C는 실제로는 ACID에 속하지 않는다.

#### 격리성

동시에 여러 클라이언트가 데이터베이스의 동일한 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다.

ACID 에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 고전적인 데이터베이스 교과서에서는 격리성을 직렬성(Serializable)이라는 용어로 공식화한다. 데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

그러나 직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다. 오라클 11g 같은 대중적인 데이터베이스 중에는 아예 구현조차 하지 않는 것도 있다. [[Oracle]] 에는 "직렬성"이라는 격리 수준이 있지만 실제로는 직렬성보다 보장이 약한 **스냅숏 격리**를 구현한 것이다.

#### 지속성

지속성(durability)은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

단일 노드 데이터베이스에서 지속성은 일반적으로 데이터가 하드디스크나 SSD 같은 비휘발성 저장소에 기록됐다는 뜻이다. 보통 디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는, 쓰기 전 로그([[write-ahead log]])나 비슷한 수단을 동반한다. 지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.

완벽한 지속성은 존재하지 않는다. 모든 하드디스크와 백업이 동시에 파괴돼 버리면 당연히 데이터베이스가 해줄 수 있는 것은 아무 것도 없다.

### 단일 객체 연산과 다중 객체 연산

![[Pasted image 20231010182757.png]]

## 완화된 격리 수준

직렬성 격리는 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장한다는 것을 의미한다.

현실적으로, 직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.

맹목적으로 도구에 의존하기보다는 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다. 그러면 사용 가능한 도구를 써서 신뢰성 있고 올바르게 동작하는 애플리케이션을 만들 수 있다.

### 커밋 후 읽기(read committed)

1. 데이터베이스에서 읽을 때 커밋된 데이터만 보기 된다(더티 읽기가 없음)
2. 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)

#### 더티 읽기 방지

커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 읽기를 막아야 한다. 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에서 보인다는 뜻이다.

- 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백되야 한다. 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 즉 실제로는 데이터베이스에 결코 커밋되지 않을 데이터를 볼 수 있다.

#### 더티 쓰기 방지

먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리면 어떻게 될까? 이를 더티 쓰기(dirty write)라고 부른다. 보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.

![[Pasted image 20231010180918.png]]

#### 커밋 후 읽기 구현

Oracle, [[PostgreSQL]], SQL Server, MemSQL 과 다른 여러 데이터베이스에서는 커밋 후 읽기 격리 수준이 기본 설정이다.

로우 수준 잠금을 사용해 더티 쓰기를 방지한다.

더티 읽기를 어떻게 막을 수 있을까? 한가지 선택은 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 하는 것이다.

그러나 읽기 잠금을 요구하는 방법은 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문에 현실에서는 잘 사용하지 않는다. 읽기만 실행하는 트랜잭션들의 응답시간에 해를 끼치며 운영성이 나쁘다.

이런 이유로 대부분의 데이터베이스는 다음과 같은 방법을 사용해 더티 읽기를 방지한다. 쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다. 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다. 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.

### 스냅숏 격리와 반복 읽기

- 백업: 백업을 하려면 데이터베이스 전체의 복사본을 만들어야 하는데 데이터베이스가 크면 몇 시간이 걸릴 수도 있다. 백업 프로세스가 실행되는 동안에도 데이터베이스에 쓰기가 실행되므로 백업의 일부는 과거 버전을, 다른 부분은 새 버전을 갖고 있을 수 있다. 이런 백업을 사용하여 복원하면 비일관성이 영속적이게 된다.
- 분석 질의와 무결성 확인: 데이터의 큰 부분을 스캔하는 질의를 실행하고 싶을 때가 있다. 이런 질의는 다른 시점의 데이터베이스의 일부를 보게 되면 불합리한 결과를 반환할 수도 있다.

스냅숏 격리는 이런 문제의 가장 흔한 해결책이다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다. 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.

#### 스냅숏 격리 구현

읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다.

데이터베이스는 커밋된 버전 여러개를 유지할 수 있어야 한다. 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문이다. 객체의 여러 버전을 함께 유지하므로 이 기법은 **다중 버전 동시성 제어(nulti-version concurrency control, [[MVCC]])** 라고 한다.

트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 아이디를 부여받고, 트랜잭션이 데이터베이스에서 데이터를 쓸 때마다 실행한 트랜잭션의 ID 가 함께 붙는다.

#### 가시성 규칙

- 읽기를 실행하는 트랜잭션이 실행한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다

데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있다.

#### 색인과 스냅숏 격리

다중 버전 데이터베이스에서 색인은 어떻게 동작할까? 하나의 선택지는 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것이다. 가비지 컬렉션이 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제할 때 대응되는 색인 항목도 삭제된다.

[[PostgreSQL]] 은 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다.

[[Couch DB]], [[Datomic]], [[LMDB]] 에서는 다른 방법을 쓴다. 이것들도 [[B-Tree]] 를 사용하지만 **추가 전용이며 쓸 때 복사되는(append-only/copy-on-write)** 변종을 사용한다. 트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다. 트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고 그것들의 자식 페이지들의 새 버전을 가리키도록 갱신된다. 쓰기에 영향을 받지 않는 페이지들은 복사될 필요가 없고 변함 없는 상태로 남는다.

추가 전용 B-Tree 를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B-Tree 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다. 나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B-Tree를 변경할 수 없으므로 트랜잭션 ID 를 기반으로 객체를 걸러낼 필요가 없다. 그러나 이 방법도 컴팩션(compaction)과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요하다.

### 갱신 손실 방지

갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때(read-modify-write 주기) 발생할 수 있다. 만약 두 트랜잭션이 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다. 이런 패턴은 다양한 시나리오에서 발생한다.

- 카운터를 증가시키거나 계좌 잔고를 갱신한다(현재 값을 읽어서 새 값을 계산하고 갱신된 값을 다시 써야 한다).
- 복잡한 값을 지역적으로 변경한다. 예를 들어 JSON 문서 내에 있는 리스트에 엘리먼트를 추가한다.
- 사용자가 편집한 내용을 저장할 때 전체 페이지 내용을 서버에 보내서 현재 데이터베이스에 저장된 내용을 덮어 쓰도록 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.

갱신 손실은 매우 흔한 문제이기 때문에 다양한 해결책이 개발됐다.

#### 원자적 쓰기 연산

여러 데이터베이스에서 원자적 갱신 연산을 제공한다. 이런 연산을 써서 코드를 표현할 수 있다면 이것들이 보통 가장 좋은 해결책이다. 예를 들어 다음 명령은 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

[[MongoDB]] 같은 문서 데이터베이스는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공하고 [[Redis]] 는 우선순위 큐(priority queue) 같은 데이터 구조를 변경하는 원자적 연산을 제공한다. 원자적 연산이 사용될 수 있는 상황에서는 이들이 보통 최선의 선택이다.

**원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해서 구현**한다. 그래서 갱신이 적용될 때 다른 트랜잭션에서 그 객체를 읽지 못하게 한다. 이 기법을 **커서 안정성(cursor stability)** 이라고 부르기도 한다. 다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 것이다.

> [!warning]
> 객체 관계형 매핑 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉬우므로 주의가 필요하다.

#### 명시적인 잠금

데이터베이스에 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다.

```sql
BEGIN TRANSACTION;

SELECT * FROM figures
    WHERE name = 'robot' AND game_id = 222
    FOR UPDATE;

-- 이동이 유효한지 확인한 후
-- 이전의 SELECT 에서 반환된 것의 위치를 갱신한다.
UPDATE figures SET position = 'c4' WHERE id = 1234;

COMMIT;
```

- `FOR UPDATE` 절은 데이터베이스가 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가리킨다.

이 방법은 동작하지만 올바르게 동작하려면 애플리케이션 로직에 대해 신중하게 생각해야 한다. 코드의 어딘가에 잠금을 추가하는 것을 잊어버려서 경쟁 조건([[Race condition]])을 유발하기 쉽다.

#### 갱신 손실 자동 감지

원자적 연산과 잠금은 read-modify-write 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다. 대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.

이 방법의 이점은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것이다. 실제로 [[PostgreSQL]] 의 repeatable read, [[Oracle]] 의 serializable, SQL Server 의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견해서 문제가 되는 트랜잭션을 어보트시킨다.

> [!NOTE]
> [[MySQL]] InnoDB 의 repeatable read 는 갱신 손실을 감지하지 않는다.

갱신 손실 감지는 애플리케이션 코드에서 어떤 특별한 데이터베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능이다. 잠금이나 원자적 연산을 쓰는 것을 잊어버려서 버그를 유발할 수는 있지만 자동으로 갱신 손실이 감지되어 오류가 덜 발생하게 해준다.

#### Compare-and-set

이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도해야 한다.

```sql
UPDATE wiki_pages SET content = 'new content'
    WHERE id = 1234 AND content = 'old content';
```

내용이 바뀌어서 더는 'old content' 와 일치하지 않으면 이 갱신은 적용되지 않는다.

> [!warning] 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있다
> 데이터베이스가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다. 데이터베이스의 compare-and-set 연산에 의존하기 전에 먼저 안전한지 확인해야 한다.

#### 충돌 해소와 복제

### 쓰기 스큐와 팬텀

## 직렬성

- 격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없다. 예를 들어 반복 읽기의 의미는 상당히 다양하다.
- 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵다.
- 경쟁 조건을 감지하는 데 도움이 되는 좋은 도구가 없다.

직렬성 격리는 보통 가장 강력한 격리 수준이라고 여겨진다. 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다. 즉 데이터베이스가 발생할 수 있는 **모든** 경쟁 조건을 막아준다.

오늘날 직렬성 격리를 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.

- 트랜잭션을 순차적으로 실행하기
- 2 Phase Lock (2단계 잠금)
- 직렬성 스냅숏 격리 같은 낙관적 동시성 제어(Optimistic concurrency control, [[Optimistic Lock]]) 기법

### 실제적인 직렬 실행

동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것이다. 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다. 그러면 트랜잭션 사이의 충돌을 감지하고 방지하는 문제를 완전히 회피할 수 있으며 결과적으로 격리 수준은 당연히 직렬성 격리가 된다.

뻔한 생각처럼 보이지만 데이터베이스 설계자들은 상당히 최근(2007년경)이 돼서야 단일 스레드 루프에서 트랜잭션을 실행하는 게 실현 가능하다고 결론내렸다. 30년 동안의 다중 스레드 동시성에 대한 생각이 변하게 된 이유는 다음과 같다.

- **램 가격이 저렴해져서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다.** 트랜잭션이 접근해야 하는 모든 데이터가 메모리에 있다면 디스크에서 읽어 오기를 기다려야 할 때보다 트랜잭션이 훨씬 빨리 실행될 수 있다.
- 데이터베이스 설계자들은 OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달았다.

트랜잭션을 순차적으로 실행하는 방법은 볼트Db/H-스토어, [[Redis]], [[Datomic]] 에서 구현돼 있다. 잠금을 코디네이션하는 오버헤드를 피할 수 있기 때문에 단일 스레드로 실행되도록 설계된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 때도 있다. 그렇지만 이들의 처리량은 하나의 CPU 코어로 제한되기 때문에, 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.

#### 직렬 실행 요약

트랜잭션 직렬 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이다.

- 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있다.
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝해야 한다.
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다.

### 2단계 잠금(2PL)

약 30년 동안 데이터베이스에서 직렬성을 구현하는 데 널리 쓰인 유일한 알고리즘이 있다. 바로 **2단계 잠금(two-phase locking, 2PL)** 이다.

> [!warning] 2PL 은 2PC 가 아니다
> 2단계 잠금(2PL)과 2단계 커밋([[Two Phase Commit]], 2PC)은 아주 비슷하게 들리지만 완전히 다르다.

더티 쓰기(dirty write)를 막는 데 잠금이 자주 사용된다. 두 개의 트랜잭션이 동시에 같은 객체에 쓰려고 하면 잠금은 나중에 쓰는 쪽이 진행하기 전에 먼저 쓰는 쪽에서 트랜잭션을 완료(어보트되거나 커밋되거나)할 때까지 기다리도록 보장해준다.

2단계 잠금도 비슷하지만 잠금 요구사항이 훨씬 더 강하다.

- 트랜잭션 A 가 객체 하나를 읽고 트랜잭션 B 가 그 객체에 쓰기를 원한다면 B 는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다
- 트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다. **2PL 을 쓸 때는 객체의 과거 버전을 읽는 게 허용되지 않는다**.

2PL 에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다. 스냅숏 격리는 **읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다**는 원칙이 있는데 이게 스냅숏 격리와 2단계 잠금의 중요한 차이다. 반면 2PL 은 직렬성을 제공하므로 앞에서 설명했던 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.

#### 2단계 잠금 구현

2PL 은 [[MySQL]](InnoDB)과 SQL server 에서 직렬성 격리 수준을 구현하는데 사용되고 DB2에서는 반복 읽기 격리 수준을 구현하는데 사용된다.

읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현한다. 잠금은 **공유 모드(shared mode)** 나 **독점 모드(exclusive mode)** 로 사용될 수 있다. 잠금은 다음과 같이 사용된다.

- 트랜잭션이 객체를 읽기 원한다면 먼저 공유 모드로 잠금을 획득해야 한다. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만 만약 그 객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있으면 이 트랜잭션이 완료될 때까지 기다려야 한다.
- 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 잠금을 획득할 수 없으므로(공유 모드든지 독점 모드든지) 그 객체에 잠금이 존재한다면 트랜잭션은 대기해야 한다.
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료(커밋 또는 어보트)될 때까지 잠금을 갖고 있어야 한다.

잠금이 아주 많이 사용되므로 교착 상태([[Dead Lock]])가 매우 쉽게 발생할 수 있다. 데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트시켜서 다른 트랜잭션이 진행할 수 있게 한다. 어보트된 트랜잭션은 애플리케이션에서 재시도해야 한다.

#### 2단계 잠금의 성능

2단계 잠금의 가장 큰 약점은 성능이다. 2단계 잠금을 쓰면 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다.

원인은 동시성이 줄어드는 것에 있다. 설계에 따라 두 트랜잭션이 어떤 식으로든 경쟁 조건을 유발하는 일을 하려고 하면 한 트랜잭션은 다른 트랜잭션이 완료될 때까지 기다려야 한다.

2PL 을 실행하는 데이터베이스는 작업부하에 경쟁이 있다면 지연 시간이 아주 불안정하고 높은 백분위에서 매우 느릴 수 있다. 견고한 연산이 필요할 때 이런 불안정성은 문제가 된다.

트랜잭션이 교착 상태 때문에 어보트돼 재시도하면 작업을 전부 다시 해야 한다. 교착 상태가 잦으면 헛수고가 심하다는 뜻도 된다.

#### 서술 잠금

직렬성 격리를 쓰는 데이터베이스는 팬텀을 막아야 한다.

회의실 예약 예제로 설명하면 한 트랜잭션이 특정 시간 범위 내에 있는 회의실 예약을 검색했다면, 다른 트랜잭션이 같은 시간 범위 내에서 동일한 회의실을 쓰는 예약을 삽입하거나 갱신하는 게 허용되지 않는다는 뜻이다.

개념상으로 **서술 잠금(predicate lock)** 이 필요하다. 서술 잠금은 앞에서 설명한 공유/독점 잠금과 비슷하게 동작하지만 특정 객체에 속하지 않고 아래와 같은 어떤 검색 조건에 부합하는 모든 객체에 속한다.

```sql
SELECT * FROM bookings
    WHERE room_id = 123 AND
        end_time > '2018-01-01 12:00' AND
        start_time < '2018-01-01 13:00';
```

- 트랜잭션 A가 위 SELECT 질의처럼 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유 모드 서술 잠금을 획득해야 한다. 다른 트랜잭션 B가 그 조건에 부합하는 어떤 객체에 독점 잠금을 갖고 있으면 A는 질의를 실행하도록 허용되기 전에 B가 잠금을 해제하기를 기다려야 한다.
- 트랜잭션 A가 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 먼저 기존 값인 ㅏ새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다. 부합하는 서술 잠금을 트랜잭션 B가 잡고 있다면 A 는 B가 종료될 때까지 기다려야 한다.

여기서 핵심 아이디어는 서술 잠금은 데이터베이스에 아직 존재하지 않지만 미래에 추가될 수 있는 객체(팬텀)에도 적용할 수 있다는 것이다. 2단계 잠금이 서술 잠금을 포함하면 데이터베이스에서 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 격리 수준이 직렬성 격리가 된다.

#### 색인 범위 잠금

유감스럽게도 서술 잠금은 잘 동작하지 않는다. 진행 중인 트랜잭션들이 획득한 잠금이 많으면 조건에 부합하는 잠금을 확인하는 데 시간이 오래 걸린다. 이 때문에 2PL 을 지원하는 대부분의 데이터베이스는 실제로는 **색인 범위 잠금(index-range locking, 다음 키 잠금(next-key locking)이라고도 한다)** 을 구현한다. 이것은 서술 잠금을 간략하게 조절하여 더 많은 객체가 해당되도록 한 것이다.

더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전하다. 예를 들어 정오와 오후 1시 사이에 123번 방을 예약하는 것에 대한 서술 잠금은 모든 시간 범위에 123번 방을 예약하는 것에 대한 잠금으로 근사할 수 있다. 또는 정오와 오후 1시 사이에 모든 방을 잠그는 것으로 근사할 수 있다. 원래의 서술 조건에 부합하는 쓰기는 분명히 근사 조건에도 부합하므로 안전하다.

어떤 방법을 쓰든지 간략화한 검색 조건이 색인 중 하나에 붙는다. 이제 다른 트랜잭션이 같은 방을 사용하거나 시간이 겹치는 예약을 삽입, 갱신, 삭제하길 원한다면 색인의 같은 부분을 갱신해야 한다. 그 과정에서 공유 잠금을 발견하고 잠금이 해제될 때까지 기다리게 된다.

색인 범위 잠금은 서술 잠금보다 정밀하지 않지만 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다.

범위 잠금을 잡을 수 있는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다. 그 테이블에 쓰는 다른 모든 트랜잭션을 멈추므로 성능에는 좋지 않지만 안전한 대비책이다.

### 직렬성 스냅숏 격리(SSI)

직렬성 격리와 좋은 성능은 근본적으로 공존할 수 없는 것처럼 보인다.

직렬성 스냅숏 격리(serializable snapshot isolation, SSI)라는 알고리즘은 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있다.

오늘날 SSI 는 단일 노드 데이터베이스(PostgreSQL 은 9.1 버전부터 직렬성 격리 수준을 제공)와 분산 데이터베이스 모두에서 사용된다.

#### 비관적 동시성 제어 대 낙관적 동시성 제어

2단계 잠금은 이른바 **비관적** 동시성 제어 메커니즘이다. 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다. 다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 **상호 배제(mutual exclusion)** 와 비슷하다.

반대로 직렬성 스냅숏 격리는 **낙관적** 동시성 제어 기법이다. 트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지(즉 격리가 위반됐는지) 확인한다. 만약 그렇다면 트랜잭션은 어보트되고 재시도해야 한다.

낙관적 동시성 제어는 경쟁이 심하면 어보트시켜야할 트랜잭션의 비율이 높아지므로 성능이 떨어진다. 시스템이 이미 최대 처리량에 근접했다면 재시도되는 트랜잭션으로부터 발생하는 부가적인 트랜잭션 부하가 성능을 저하시킬 수 있다.

그러나 예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.

이름이 나타내듯이 SSI 는 스냅숏 격리를 기반으로 한다. 즉 트랜잭션에서 실행되는 모든 읽기는 데이터베이스의 일관된 스냅숏을 보게 된다. 이게 이전의 낙관적 동시성 제어 기법과 크게 다른 점이다. SSI 는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.

#### 뒤쳐진 전체에 기반한 결정

스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최신이 아닐 수 있다. 도중에 데이터가 변경됐을 수 있기 때문이다. 직렬성 격리를 제공하려면 데이터베이스는 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 그런 상황에서는 트랜잭션을 어보트시켜야 한다.

- 오래된(stale) MVCC 객체 버전을 읽었는지 감지하기(읽기 전에 커밋되지 않은 쓰기가 발생했음)
- 과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)

#### 오래된 MVCC 읽기 감지하기

스냅숏 격리는 보통 다중 버전 동시성 제어([[MVCC]])로 구현한다는 점을 다시 떠올려보자. 데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 한다. 트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인해야 한다. 커밋된 게 있다면 트랜잭션은 어보트돼야 한다.

#### 과거의 읽기에 영향을 미치는 쓰기 감지하기

두 번째 경우는 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 때다.

트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 한다. 이 과정은 영향받는 키 범위에 쓰기 잠금을 획득하는 것과 비슷하지만 읽는 쪽에서 커밋될 때까지 차단하지 않는다. 커밋하길 원할 때 충돌되는 쓰기가 이미 커밋됐다면 어보트된다.

#### 직렬성 스냅숏 격리의 성능

어떤 경우에는 다른 트랜잭션에서 덮어쓴 정보를 트랜잭션이 읽어도 괜찮다. 어떤 일이 있었는지에 따라 때로는 데이터가 덮어쓰여졌음에도 실행 결과가 직렬적이라는 것을 증명하는 게 가능하다. [[PostgreSQL]] 은 불필요한 어보트 개수를 줄이기 위해 이 이론을 사용한다.

2단계 잠금과 비교할 때 직렬성 스냅숏 격리의 큰 이점은 트랜잭션이 다른 트랜잭션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없다는 것이다. 스냅숏 격리하에서와 마찬가지로 쓰는 쪽은 읽는 쪽을 막지 않고 읽는 쪽도 쓰는 쪽을 막지 않는다. 특히 읽기 전용 질의는 어떤 잠금도 없이 일관된 스냅숏 위에서 실행될 수 있다. 읽기 작업부하가 심한 경우에 매우 매력적이다.

순차 실행과 비교할 때 직렬성 스냅숏 격리는 단일 CPU 코어의 처리량에 제한되지 않는다.

어보트 비율은 SSI 의 전체적인 성능에 큰 영향을 미친다. 이를테면 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워서 SSI 는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다. 그러나 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감할 것이다.

## Conclusion

트랜잭션은 애플리케이션이 어떤 동시성 문제와 어떤 종류의 하드웨어와 소프트웨어 결함이 존재하지 않는 것처럼 동작할 수 있게 도와주는 추상층이다.

아래 키워드를 다시 한 번 살펴보자.

- 더티 읽기
- 더티 쓰기
- 읽기 스큐(비반복 읽기)
- 갱신 손실
- 쓰기 스큐
- 팬텀 읽기

완화된 격리 수준은 이런 이상 현상 중 일부는 막아주지만 나머지는 애플리케이션 개발자가 수동으로 처리해야 한다. 직렬성 격리만 이 모든 문제들로부터 보호해준다. 직렬성 트랜잭션을 구현하는 세 가지 다른 방법을 설명했다.

- 순서대로 실행하기
- 2단계 잠금
- 직렬성 스냅숏 격리

## Reference

- https://m-falcon.tistory.com/527
